# Class文件
常量池可以理解为Class文件中的资源仓库，主要存放两大常量：字面量和符号引用。
字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。
而符号引用属于编译原理方面的概念包含下面三类常量：
1.类和接口的全限定名
2.字段的名称和描述符
3.方法的名称和描述符


# 类加载过程
加载->验证->准备->解析->初始化->使用->卸载   其中验证、准备、解析统称为连接
## 加载
加载阶段虚拟机主要完成三件事情：
1.通过一个类的全限定名获取定义此类的二进制字节流
2.将这个字节流所代表的静态存储结构转化成方法区的运行时数据结构
3.在内存中生成一个代表该类的java.lang.Class对象，作为方法区中该类各种数据的访问入口。
## 验证
验证主要目的是确保class文件的字节流信息符合虚拟机的要求，不会对虚拟机造成危害
## 准备
准备是正式为类变量分配内存并设置变量初始值的阶段，变量使用的内存在方法区中分配。这里有两个容易混淆的概念：
首先，进行内存分配的仅包含类变量（静态变量，被static修饰的变量），不包含实例变量，实例变量将在对象实例化时随着对象一起分配在java堆中。
其次，初始值 通常情况下 是数据结构的零值，例如 public static int value=123; value在准备阶段过后初始值为0而不是123，将value赋值为123
的操作将在初始化阶段完成。
## 解析
解析过程是虚拟机将常量池类的符号引用替换为直接引用的过程。

符号引用是一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到
内存中。各种虚拟机是实现的内存布局可以不同，但他们接受的符号引用必须一致，因为符号引用的字面值形式明确定义在java虚拟机规范的
Class文件格式中。
直接引用可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关，同一个符号引用在
不同虚拟机实例上翻译出来的直接引用往往不同。如果有个直接引用，那引用的目标必定已经在内存中存在。
## 初始化
类初始化是类加载最后一个阶段
前面的类加载过程除了加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才是真正执行类
中定义的java程序代码(字节码)。

初始化阶段是执行类构造器clinit方法的过程。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的
语句合并产生的。编译器收集顺序是由语句在源文件中出现的顺序决定，静态语句块只能访问到定义在静态语句块之前的变量，定义在他之后的变量，在
前面的静态语句块中可以赋值，但是不可以访问(system.out.print)。
clinit方法与类的构造函数（或者说实例构造函数init）不同。他不需要显示的调用父类构造器，虚拟机会保证在之类的clinit方法执行
之前，父类的clinit方法已经执行完毕。因此在虚拟机中第一个执行的clinit方法的类肯定是java.lang.Object。
clinit方法对于类和接口来说不是必须的，如果类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit方法。
接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口和类一样都会生成clinit方法。但接口与类不同的是，执行接口的clinit方法
不需要限制性父接口的clinit方法。只有当父接口定义的变量使用时，父接口才会初始化，另外，接口的实现类在初始化时也一样不会执行接口的clinit方法。
  
虚拟机会保证一个类的clinit方法在多线程环境中被正确的加锁同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit方法，
其他线程都需要阻塞等待，知道活动线程执行clinit方法完毕。如果一个类的clinit方法中有耗时很长的操作，就会造成多个进程阻塞，在实际应用中这种
阻塞往往比较隐蔽。   需要注意的是，其他线程虽然会被阻塞，但是如果执行clinit方法的那条线程退出clinit方法后，其他线程唤醒之后不会再次进入
clinit方法。同一个类加载器下，一个类型只会初始化一次。

