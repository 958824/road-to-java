## 1.用静态工厂方法代替构造器
优势
（1）静态工厂方法有名字
（2）不必每次调用时都创建一个新对象（享元模式）
（3）静态工厂方法可以返回任何子类型对象
（4）所返回的对象类可以随着每次调用发生变化，取决于静态方法的参数值
（5）方法返回的对象所属类，在编写包含该静态工厂方法的类可以不存在（服务提供者框架）
享元模式实例Client.java
服务提供者框架 Subwaydemo.java


## 2.遇到多个构造器参数时要考虑使用构建器
多个参数的构造器客户端代码会难写，难以阅读，改进方式可以使用javabean模式，先调用无参构造器创建对象，再调用setter方法设置参数，
但是这种方式不是线程安全的，需要额外保证其线程安全性。
构建器模式
public class CreatorMode {
    private final int id;
    private final int name;
    private final int desc;
    private final int version;

    public static class builder {
        private final int id;
        private final int name;

        private int desc = 0;
        private int version = 0;

        public builder(int id, int name) {
            this.id = id;
            this.name = name;
        }

        public builder desc(int val) {
            desc = val;
            return this;
        }

        public builder version(int val) {
            version = val;
            return this;
        }

        public CreatorMode build() {
            return new CreatorMode(this);
        }
    }
    private CreatorMode(builder b) {
        this.id = b.id;
        this.name = b.name;
        this.desc = b.desc;
        this.version = b.version;
    }
    public static void main(String[] args) {
        CreatorMode demo=new builder(1,2).desc(3).version(4).build();
        System.out.println(demo.id+" "+demo.name+" "+demo.desc+" "+demo.version); // 1 2 3 4
    }
}

## 3.使用私有构造器或者枚举类型强化Singleton属性
实现singleton有两个常见的方法。这两种方法都要保证构造器为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。
方法一： 公有静态成员为final域
public class Singleton {
        public static final Singleton instance=new Singleton();
        private Singleton(){}
}

